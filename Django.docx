# 获取cookie： request.COOKIES[key]安装（ubuntu）django1.7及以上版本

	pip install django	(python2)
	pip3 install django	(python3)

# 创建项目

	django-admin.py startproject projectname(工程名)
	创建后，在当前目录将生成projectname文件夹， 其文件数结构如下：
		projectname
		├── manage.py
		└── projectname
			├── __init__.py
			├── settings.py
			├── urls.py
			└── wsgi.py
	注：
		manage.py
			一个实用的命令行工具，可以让你以各种方式与该django项目进行交互
		__init__.py
			一个空文件，告诉python该目录是一个python包
		settings.py
			该项目的配置
			setting中关于数据库ENGINE的设置
			MySQL (django.db.backends.mysql)
			PostGreSQL (django.db.backends.postgresql_psycopg2)
			Oracle (django.db.backends.oracle) and NoSQL DB
			MongoDB (django_mongodb_engine)
	
		urls.py
			该项目的url声明，一份由django驱动的网站"目录",项目创建的各个环节和要调用的函数
		wsgl.py
			一个兼容WSGI的web服务器的入口	
	
		diango-admin.py 是安装django之后的管理工具
		diango-admin.py和manage.py
		这两个文件代码和包含命令基本是一样的，只不过django-admin.py一般只用来创建项目，而manage.py用来管理创建好了的项目
	
	python3 manage.py startapp app_name或者django-admin.py startapp app_name 创建应用app(要先cd到当前项目目录)
	会在manage.py同级目录下生成
	├── app_name
	│   ├── admin.py	与后台相关
	│   ├── apps.py
	│   ├── __init__.py
	│   ├── migrations
	│   │   ├── __init__.py
	│   │   └── __pycache__
	│   ├── models.py 	类似scrapy的items
	│   ├── __pycache__
	│   ├── tests.py
	│   └── views.py 	具体要通过网址显示的视图
注意：
	新建的app要田添加到settings.py文件中，否则django就不能自动找到app中的模板文件(app_name/tenplates/模板文件)和静态文件(/app_name/static/静态文件)



一些命令：
	创建数据库表单 或 更改数据库表或字段
		python3 manage.py makemigrations
		python3 manage.py migrate
	上述两行命令会对app的models.py文件进行检测，自动发现更改并创建对应表单到数据库中
	

	python3 manage.py flush	清空数据库 只留下空表单
	
	python3 manage.py collectstatic 收集静态文件
	
	python3 manage.py createsuperuser 创建超级管理员
	python3 manage.py changepasswoord username 修改用户密码
	
	导出 导入数据
		python3 manage.py dumpdata app_name > app_name.json
		python3 manage.py loaddata app_name.json
	
	django项目环境终端
		python3 manage.py shell 
	
	数据库命令行
		python3 manage.py dbshell Django会自动进入在setting.py中设置的数据库，如果是mysql等，会要求输入数据库用户密码，然后可以直接执行数据库的sql语句
	python3 manage.py 可以看到详细的参数列表

# 启动

	python3 manage.py runserver 8000
	上面的8000为端口号。如果不说明，那么端口号默认为8000
	如果想要别的电脑也能访问 则要python3 manage.py runserver ip:port

# 操作

	在urls.py中修改代码，可以将URL与要操作的函数进行绑定
	详情见：
		http://www.runoob.com/django/django-first-app.html

# 常用库\函数等
​	from django.http import HttpResponse
​		HttpResponse 是用来向网页返回内容，如print一样，区别在与print输入到屏幕，HttpResponse输出到网页

# virtualenv（ubuntu安装步骤）
​		可以用virtualenv来管理多个开发环境
​	安装：
​		sudo pip3 install virtualenv virtualenvwrapper
​		修改 ~/.bashrc 结尾添加如下语句 （$HOME/.virtualenvs 要在自己创建 是virtualenv虚拟环境的路径）
​			export WORKON_HOME=$HOME/.virtualenvs
​			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 # 指定用python3
​			export PROJECT_HOME=/home/cy/eclipse-workspace_py/Django/virtualenvs # 工程路径
​			source /usr/local/bin/virtualenvwrapper.sh #virtualenv的执行脚本
​	常用命令：
​		mkvirtualenv zqxt : 创建运行环境zqxt
​		mkproject zqxt : 创建zqxt项目和运行环境zqxt
​		workon zqxt : 工作在zqxt环境
​		rmvirtualenv zqxt : 删除运行环境zqxt （在删除之前要关闭运行环境，deactivate）
​		lsvirtualenv : 列出可用的运行环境
​		lssitepackages : 列出当前环境安装的包

# 静态文件

## 引入

1. ```HTML
   <script src="/static/jquery-3.3.1.min.js"></script>
   ```

2. ```HTML
   现在head标签中加入下一句{% load staticfiles %}
   然后用下句代替法一
   <script src='{% static "jquery-3.3.1.min.js" %}'></script>
   推荐使用法2
   ```

# 视图

## 视图函数常用函数/属性

### request相关

request.method

​	判断是get方式或者post等

request.path

​	请求页面的全路径，不包括域名

request.get_full_path()

​	请求页面的全路径，及参数

request.GET/request.POST

### 网页渲染

render(推荐使用,两者效果类似,render_toresponse参数中不用加request,其他一样,推荐使用render)

render_to_response

### 网页跳转

redirect 参数是路径(url)

# 模板

## 模板语法

**变量用{{}}双大括号引用,功能类的,如循环 判断等用{% %}引用**

1. 列表，字典，类的实例的使用
2. 循环：迭代显示列表，字典等中的内容
3. 条件判断：判断是否显示该内容，比如判断是手机访问，还是电脑访问，给出不一样的代码。
4. **标签**：for，if 这样的功能都是标签。
5. **过滤器**：管道符号后面的功能，比如{{ var**|**length }}，求变量长度的 length 就是一个过滤器。

### 变量

用{{}}双大括号来引用变量

{{var_name}}

#### Template和Context对象

#### 万能的句点符(深度变量的查找)

#### 变量的过滤器(filter)

语法格式:  {{obj|filter:param}} obj是变量,filter写对应的过滤器函数,param是函数的参数,注意:左右不要有空格,|是管道符

**filter常用函数**

1. **add** 给变量加上相应的值
2. **addslashes** 给变量中的引号前加上斜线
3. **capfirst** 将首字母大写
4. **cut** 从字符串中移除指定的字符
5. **date** 格式化日期字符串
6. **default** 如果是false,就替换成设置的默认值,否则就用本来的值
7. **default_if_noe** 如果是None,就替换成设置的默认值,否则就使用本来的值

### 标签

{% 标签 %}

```html
<!--if-->
{% if num == 0 %}
	0
{% elif num == 1 %}
	1
{% else num == 0 %}
	else
{% endif %}

<!--for-->
{% for item in items %}
	<h1>{{ item }}</h1>
	<p>{{ forloop.counter }}:{{ item }}</p>
{% endfor %}
<!--
forloop.counter 表示循环的次数,从1开始计数,第一次循环设为1
forloop.counter0 类似forloop.counter,但是forloop.counter0从0开始计数,第一次循环为0
forloop.revcounter/forloop.revcounter0
forloop.first 当第一次循环时值为True,在特殊情况下很有用

forloop变量只能在循环中得到,当模板解析器到达{{% endfor %}}时,forloop就消失了
如果你的模板context中已经包含了一个叫forloop的变量,Django会用{% for %}标签替代它
Django会在for标签的块中覆盖你定义的forloop变量的值
在其他非循环的地方,自定义的forloop变量仍然有用
-->

<!--csrf_token 用于生成crsf_token标签,用于防止跨站攻击验证,设置该项后,在views.py中调用的render_to_response方法不会生效
在某个post请求第一次提交时,要加上该标签,不然安全验证不能通过,实际的显示作用是django将该标签渲染成一个带有name和value的input标签,只有有了该name value键值对,才能通过验证
-->
{% csrf_token %}

<!--empty-->
{% empty %}

<!--url 
后跟一个url或者路径,引用路由配置的地址
-->
{{% url %}}

<!--with
用更简单的变量名代替复杂的变量名
-->
{% with total=dafafafadfafadfasdfas %}
{{total}}<!--用total代替后面的数据,带仅限于该with标签内有效-->
{% endwith %}

<!--load
加载标签库
-->
{% load %}

<!--verbatim
禁止render
-->
{% verbatim %}
	{{ hello }}
{% endverbatim %}
```

### 自定义filter(自定义filter函数)

1. 在app中创建templatetags模块(必须有)
2. 在上述模块下创建任意py文件,代码类似如下:

```python
from django import template
from django.utils.safestring import mark_safe

'''
register  的名字是固定的,不可改变成别的名字
'''
register = template.Library()

'''
filter函数只能传入两个函数,第一个函数默认是filter修饰的变量,第二个参数才是filter, 如:<h1>{{ x|filter_multi:5 }}</h1>,x是v1,5是v2
filter可以用在if等语句中,simple_tag不可以
'''
@register.filter 
def filter_multi(v1, v2):
    return v1 * v2
'''
simple_tag是用register.simple_tag装饰,且参数不限个数,用{%  simple_tag %}调用
<h1>{% simple_tag_multi x y z %}</h1>
'''
@register.simple_tag
def simple_tag_multi(x, y, z):
    return x*y*z
```

3. 在使用自定义的filter或者自定义的simple_tag之前,要在html文件中用load导入之前创建的py文件,{% load myTag %}
4. 自定义simple_tag和自定义filter类似,不过使用方法不同

### extends 模板继承

继承的html中，所有的block块都是灵活的，可以被修改

#### 使用

1. 子模板第一行以extends语法开头

   如： { extends "base.html"} ，表示继承base.html

2. 父模板中的block标签块都可以被修改

3. 不允许同一个模板中出现重名的block

### include

使用：

1. 使用前要导入 ,{% load staticfiles %},导入后就可以使用include标签
2. {include "home.html" }

# ORM(object relational mapping)

## win平台django上使用mysql的坑（python manage.py makemigrations python manage.py migrate）

1. django默认是使用MySQLdb，但是python3不支持，需要在setting.py同级的init.py文件中加入如下两句：

   ```python
   import pymysql
   pymysql.install_as_MySQLdb()
   ```

2. django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None

   解决办法：

   找到Python安装路劲下的Python36-32\Lib\site-packages\django\db\backends\mysql\base.py文件

   将文件中的如下代码注释

   ```python
   if version < (1, 3, 3):
   
   	raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)
   ```

3. django执行python manage.py makemigrations 时报错AttributeError: 'str' object has no attribute 'decode'

   解决：

   ​	将operations,py文件的

   ​	query = query.decode(errors='replace') 中的decode改成encode

4. 再执行

   python manage.py makemigrations + （app_name）
   python manage.py migrate

   创建表



## **数据库接口**相关的接口（QuerySet API)

**models.py中的**

​	**类 对应 数据库的表**

​	**类对象 对应 数据库该表的一条数据**

​	**类的属性 对应 该表中的字段**

### QuerySet 创建对象的方法

```python
from blog.models imort Blog
# 法一
b = Blog(name='python基础', author='cy')
b.save()# 用此法创建数据对象，必须要调用save方法后才会在数据库里生成数据
# 法二
Blog.objects.create(name='python基础', author='cy')
# 法三
b = Blog()
b.name = 'python基础'
b.author = 'cy'
# 法四,尝试获取，不存在则创建，可以防止重复创建
Blog.objects.get_or_create(name='python基础', author='cy')
'''
前三种方法返回的都是对应的object，
最后一种方法返回是一个元组，(object,True/False)，创建时返回True,已经存在返回False
'''
```

### QuerySet 对象的获取

```python
# 查询所有 返回列表
Blog.objects.all() 
# 切片操作
Blog.objects.all()[:10]
# 获取一条，多条会报错，返回的是一条
Blog.objects.get(author='cy')
# filter 筛选符合条件的,返回的是set
Blog.objects.filter(author='cy')
# 等于Person.objects.filter(name__exact="abc") 名称严格等于 "abc" 的人
Blog.objects.filter(name="abc") 
# 名称为 abc 但是不区分大小写，可以找到 ABC, Abc, aBC，这些都符合条件
Blog.objects.filter(name__iexact="abc") 
# 名称中包含 "abc"的人
Blog.objects.filter(name__contains="abc") 
#名称中包含 "abc"，且abc不区分大小写
Blog.objects.filter(name__icontains="abc") 
# 正则表达式查询
Blog.objects.filter(name__regex="^abc")
# 正则表达式不区分大小写
Blog.objects.filter(name__iregex="^abc")

# filter是找出满足条件的，当然也有排除符合某条件的
# 排除包含 WZ 的Person对象
Blog.objects.exclude(name__contains="WZ") 
# 找出名称含有abc, 但是排除年龄是23岁的
Blog.objects.filter(name__contains="abc").exclude(age=23) 

```

### QuerySet 对象的修改

修改推荐使用update方法，效率高

```python
Blog.objects.filter(author='cy').update(author='cy123')

```

### QuerySet 对象的删除

```python
# 调用delete方法
Blog.objects.filter(author='cy').delete()
```

QuerySet对象的常用方法，详见https://docs.djangoproject.com/en/dev/ref/models/querysets/

## 一对多

如：

​	**书与出版社的关系:**

​		一个出版社可以出版多本书，故出版社是一，书是多，

​		外键一般建在多的一方

​		

### 一对多 查询 （基于QuerySet对象）

```python
class Book(models.Model):
    name = models.CharField(max_length=20)
    price = models.IntegerField()
    pub_date = models.DateField()
    author = models.CharField(max_length=40, null=True)
    #author = models.ForeignKey('Author')
    publish = models.ForeignKey('Publish')


class Publish(models.Model):
    name = models.CharField(max_length=20)
    place = models.CharField(max_length=20)
'''
publish是Book的外键

b1 = Book.objects.filter(author='cy')[0]
p1 = b1.publish
p1.name

p2 = Publish.objects.get(name='人民出版社')
p2.book_set.all().values('author')
'''
```

## 一对多 查询 （基于双下划线查询,双下划线用在filter和values中）

```python
Book.objects.filter(publish__name='北京出版社').values('name', 'price')
Book.objects.filter(name='基础').values('publish__name')
print(Book.objects.filter(publish__name='人民出版社').values('author__name'))

Publish.objects.filter(book__name='基础').values('name')
```



 

### 一对多 添加

```python
# 法一
Book.objects.create(name='基础', price=20, author_id=1, pub_date='2017-12-12', publish_id=1)
# 法二
p1 = Publish(name='人民出版社', city='北京')
p1.save()

num = random.randint(1, 100)
a1 = Author.objects.create(name='cy'+str(num), age=18)

Book.objects.create(name='基础', price=20, author=a1, pub_date='2017-12-12', publish=p1)
# 法三
p1 = Publish.objects.create(name='人民出版社')[0]
Book.objects.create(name='基础', price=20, author_id=1, pub_date='2017-12-12', publish=p1)
```

## 多对多

**多对多关系必须依赖第三张表**

**多对多关系才会创建第三张表**

**有外键时，才会创建一个后缀为_id的字段**

**跨表查询用__**

如：book_author关系,要依赖于字段为book_id和author_id的第三张表

```python
class Book(models.Model):
    name = models.CharField(max_length=20)
    price = models.IntegerField()
    pub_date = models.DateField()
    # author = models.ForeignKey('Author', on_delete=None, null=False)
    publish = models.ForeignKey('Publish', on_delete=None, null=True)
    author = models.ManyToManyField('Author')  # 多对多


class Publish(models.Model):
    name = models.CharField(max_length=20)
    city = models.CharField(max_length=20)


class Author(models.Model):
    name = models.CharField(max_length=32)
    age = models.IntegerField()

    
'''
多对多关系中，由于一本书可以对应多个作者，故Book.objects.get(id=3).author得到的是QuerySet
'''
Book.objects.get(id=3).author.all().values('name', 'age')# id为3的书的作者的name age，返回的queryset对象中是存放了name、age的字典，<QuerySet [{'id': 2, 'class_name': 'django二班'}, {'id': 7, 'class_name': 'django三班'}, {'id': 8, 'class_name': 'django一班'}, {'id': 9, 'class_name': 'django四班'}]>
Book.objects.get(id=3).author.all().values_list('name', 'age')# id为3的书的作者的name age，返回的queryset对象中是存放了name、age的元组,<QuerySet [(2, 'django二班'), (7, 'django三班'), (8, 'django一班'), (9, 'django四班')]>

# 逆向查找，用类名(类名的小写)_set，前提是两者通过外键关联，也可通过设置外键中的参数related_name来替代类名_set
Author.objects.get(id=2).book_set.all() # id为2的作者出的所有书的信息


```

### 多对多添加

```python
b1 = Book.objects.get(id=3)
a1 = Author.objects.all()
b1.author.add(*a1)
b1.author.add([2, 3])#2 3 为作者的id
b1.author.set([1, 2, 3]) # 重置
```



### 多对多删除

```python
b1 = Book.objects.get(id=3)
a1 = Author.objects.all()
b1.author.remove(*a1) # 全删除
b1.author.remove(1)# 删除书b1中id为1的作者
b1.author.clear()  

```

## 外键关联删除

## models参数详解

```python
# 通用参数，在所有的field（charfield interfield等）中都有的参数
null # 数据库中该字段是否可为空
db_column # 数据库中该字段的名称
default # 数据库中字段的默认值

primary_key # 是否为主键，唯一，不可为空
db_index # 数据库中是否可以建立索引
unique # 数据库中是否可以建立唯一索引

unipe_for_data # 数据库中字段（日期）部分是否可以建立唯一索引、
unipe_for_month # 数据库中字段（月）部分是否可以建立唯一索引
unipe_for_year # 数据库中字段（年）部分是否可以建立唯一索引

verbose_name # admin中显示的字段名称
blank # admin中是否允许用户输入为空
editable # admin中是否可以编辑
help_text # admin中该字段的提示信息
choices # admin中显示选择框的内容，用不动的数据放在内存中从而避免跨表操作，？？？不懂

error_message # 自定义错误信息，和form组件的类似
validators # 自定义验证

# 特殊的参数，
# 一对多 外键
ForeginKey
	to， # 要进行关联的表明
    to_field, # 要关联的表中的字段名称
    on_delete, # 当删除关联表中的数据时，当前表与其关联的数据的行为
    	'''
    		- models.CASCADE 删除关联数据，与之关联的数据也删除
    		- models.DO_NOTHING 删除关联数据， 报错IntegrityError
    		- models.PROTECT 删除关联数据 报错ProtectedError
    		- models.SET_NULL 删除关联数据 与之关联的值设置为null(前提ForeginKey字段要设置为可空)
    		- models.SET_DEFAULT，删除关联数据 与之关联的值设置为默认值(前提ForeginKey字段要设置了默认值)
    		- models.SET 删除关联数据
    			a. 与之关联的值设置为指定值，models.SET(指定值)
    			b. 与之关联的值设置为可执行对象的返回值，models.SET(可执行对象)
    	'''
    related_name, # 反向操作时，使用的字段名，用于替代 表名_set
    related_query_name, # 反向操作时，使用的连接前缀，用于替换 表名
    
    limit_choices_to， # 在admin或ModelForm中显示关联数据时，提供的条件，如： limit_choices_to = {'id__gt':1} id大于1
    parent_link, # 在admin中显示是否关联外键
    
    db_constraint, # 是否在数据库中创建外键约束


oneToOneField 
	# 继承于Foreginkey ，比外键多一个唯一索引，即外键_id是唯一的

# 多对多
to
related_name
related_query_name
limit_choices_to
synmetrical, # 仅使用于多对多关联时，synmetrical用于指定内部是够创建反向操作的字段
through, # 自定义第三张表时， 使用字段用于指定关系表
through_field, #自定义第三张表时，使用该字段用于指定关系表中那些字段多对多关系表
db_constraint, # 是否在数据库中创建外键约束
db_table, # 默认创建第三张表时，数据库中表的名称


class Cart(models.Model):
    user = models.ForeignKey(
        MyUser,
        verbose_name="用户"
    )
    goods = models.ForeignKey(
        Goods,
        verbose_name="商品"
    )
    num = models.IntegerField(
        verbose_name="商品数量"
    )
    is_select = models.BooleanField(
        default=True,
        verbose_name="选中状态"
    )
 
    class Meta:
        # 联合约束   其中goods和user不能重复
        unique_together = ["goods", "user"]
        # 联合索引
        index_together = ["user", "goods"]
```



# admin

## 创建管理员账号

```python
python manage.py createsuperuser # 执行该命令后，按照提示创建管理员账号密码
```

创建管理员账号后，python manage.py runserver port 运行服务；

浏览器访问url+admin，即可进入django自带的原始后台管理；

进入后台后，可进行多种操作，如添加管理员(添加的新管理员要加入staff后才能登录)

1. 进入到app的同级目录下,修改admin.py（没有admim.py则先创建再修改）

2. 在admin.py中注册数据库的表单

   ```python
   from django.contrib import admin
   
   # Register your models here.
   from . import models
   
   admin.site.register(models.Book)
   admin.site.register(models.Author)
   admin.site.register(models.Publish)
   ```

## Django admin的配置

```python
class BookAdmin(admin.ModelAdmin):
    # 在admin后台中显示的字段，不可加上多对多关系
    list_display = ('id', 'name', 'price', 'pub_date')
    # 在admin后台中可编辑的字段
    list_editable = ('price',)
    # 作者可搜索，水平显示
    filter_horizontal = ('author',)
    # 每页显示几个
    list_per_page = 3
    # 按照什么字段过滤
    list_filter = ('pub_date', 'publish')
# 将定制的BookAdmin绑定到Book上，再注册
admin.site.register(models.Book, BookAdmin)
admin.site.register(models.Author)
admin.site.register(models.Publish)
```

# cookie session

## cookie

```python
# cookie是保存在客户端（浏览器）中的键值对，以文件格式保存在本地
获取cookie： request.COOKIES[key]
设置cookie： response.set_cookie（key, value)
```

## session

```python
#session默认在服务器保存 15 天，session可以保存在数据库、文件或者缓存中去
获取session： request.session(key)
设置session: request.session[key] = value
删除session: del request_session[key]# 这个删除其实就是服务器数据库的session_data更新为一个其他的值，并没有立即删除
request.session.set_expiry(value)# 设置session的有效时间
# value为整数时，表示秒数
# 为datetime或timedelta时,会在该value之后失效
# 为0时，用户关闭浏览器session会立即失效
# 为None时，session会依赖全局session失效策略
```

## cookie和session的区别

1. cookie是保存在浏览器端的键值对，session是保存在服务端的键值对
2. cookie的存储量有限，一般不超过4096字节，且安全性不高，session存储量比较大，安全性较高
3. cookie和session使用时，cookie中的键sessionid的值，对应的是该session中对应的值



# django的生命周期

## 请求的生命周期

指当用户点从浏览器点击时，django后台经历的流程

1. 构造请求字符串(请求头+分隔符（\r\n\r\n）+请求体)，发送http请求

2. 服务端接受请求，在路由分发中从上往下查找，找不到则报404

3. 执行所查找的路由对应的函数（对于cbv来说， 找到对应的class后去执行django的dispatch方法，找到后去执行对应的方法）

   cbv, url->类,该类要继承django.view，而该view在base.py中，；fbv, url->函数

4. 业务处理

   - 根据个人需求自定
   - 操作数据库
     - 可以用原生的SQL
     - 用django的ORM
   - 响应内容
     - 响应头
     - 响应体

# Ajax

悄悄的向后台发一个请求

```html
$.ajax({
	url: '要提交的url，类似form表单中的action属性'，
	type: 'POST'/'GET',
	data: {}, //包含请求体的字典，key可加引号也可不加
	datatype: 'JSON'/text/html/xml
    //traditional:true,// 当data中的value为list时（value不能为dict类型，想为dict时要用json转成字符串然后再发送），需要设置这个选项为true
	success:function(arg){
		//回调函数，arg是服务端返回的信息
		console.log(arg)
	}
	error:function(){

	}
})


//$('# form表单的id').serialize()  可以将from表单里的数据全部提交

```

# 分页

## django的内置分页

```python
'''
内置分页主要是两个对象，Paginator、Page, 可以通过这两个对象得到当前页、上一页、下一页、是否有下一页、是否有上一页、总页数等
'''
```

## 扩展django的内置分页

**本质就是集成内置分页进行优化**

详见练习项目django_form

## 自定义分页

# Form组件

## 作用

1. 对用户提交的数据进行检验
2. 生成html代码（生成错误信息相关的html代码或者输入框相关的html代码等）

## 使用

1. 创建类，继承django.forms.Form
2. 在类中创建要输入的字段
3. 根据请求类型的不同，返回不同的html代码（该html代码可以由form组件生成）

## form组件常用字段及参数详解

```python
'''
创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;
initial
'''
# 初始值，input框里面的初始值。

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三"  # 设置默认值
    )
    pwd = forms.CharField(min_length=6, label="密码")

error_messages

# 重写错误信息。

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三",
        error_messages={
            "required": "不能为空",
            "invalid": "格式错误",
            "min_length": "用户名最短8位"
        }
    )
    pwd = forms.CharField(min_length=6, label="密码")

password

class LoginForm(forms.Form):
    ...
    pwd = forms.CharField(
        min_length=6,
        label="密码",
        widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True)
    )

radioSelect

# 单radio值为字符串

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三",
        error_messages={
            "required": "不能为空",
            "invalid": "格式错误",
            "min_length": "用户名最短8位"
        }
    )
    pwd = forms.CharField(min_length=6, label="密码")
    gender = forms.fields.ChoiceField(
        choices=((1, "男"), (2, "女"), (3, "保密")),
        label="性别",
        initial=3,
        widget=forms.widgets.RadioSelect
    )

# 单选Select

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.ChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),
        label="爱好",
        initial=3,
        widget=forms.widgets.Select
    )

# 多选Select

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),
        label="爱好",
        initial=[1, 3],
        widget=forms.widgets.SelectMultiple
    )

# 单选checkbox

class LoginForm(forms.Form):
    ...
    keep = forms.fields.ChoiceField(
        label="是否记住密码",
        initial="checked",
        widget=forms.widgets.CheckboxInput
    )

# 多选checkbox

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"),),
        label="爱好",
        initial=[1, 3],
        widget=forms.widgets.CheckboxSelectMultiple
    )

# 关于choice的注意事项：

在使用选择标签时，需要注意choices的选项可以从数据库中获取，但是由于是静态字段 ***获取的值无法实时更新***，那么需要自定义构造方法从而达到此目的。

方式一：

from django.forms import Form
from django.forms import widgets
from django.forms import fields

 
class MyForm(Form):
 
    user = fields.ChoiceField(
        # choices=((1, '上海'), (2, '北京'),),
        initial=2,
        widget=widgets.Select
    )
 
    def __init__(self, *args, **kwargs):
        super(MyForm,self).__init__(*args, **kwargs)
        # self.fields['user'].widget.choices = ((1, '上海'), (2, '北京'),)
        # 或
        self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption')

方式二：

from django import forms
from django.forms import fields
from django.forms import models as form_model

 
class FInfo(forms.Form):
    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())
    # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())

 

Field
    required=True,               是否允许为空
    widget=None,                 HTML插件
    label=None,                  用于生成Label标签或显示内容
    initial=None,                初始值
    help_text='',                帮助信息(在标签旁边显示)
    error_messages=None,         错误信息 {'required': '不能为空', 'invalid': '格式错误'}
    show_hidden_initial=False,   是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直）
    validators=[],               自定义验证规则
    localize=False,              是否支持本地化
    disabled=False,              是否可以编辑
    label_suffix=None            Label内容后缀
 
 
CharField(Field)
    max_length=None,             最大长度
    min_length=None,             最小长度
    strip=True                   是否移除用户输入空白
 
IntegerField(Field)
    max_value=None,              最大值
    min_value=None,              最小值
 
FloatField(IntegerField)
    ...
 
DecimalField(IntegerField)
    max_value=None,              最大值
    min_value=None,              最小值
    max_digits=None,             总长度
    decimal_places=None,         小数位长度
 
BaseTemporalField(Field)
    input_formats=None          时间格式化   
 
DateField(BaseTemporalField)    格式：2015-09-01
TimeField(BaseTemporalField)    格式：11:12
DateTimeField(BaseTemporalField)格式：2015-09-01 11:12
 
DurationField(Field)            时间间隔：%d %H:%M:%S.%f
    ...
 
RegexField(CharField)
    regex,                      自定制正则表达式
    max_length=None,            最大长度
    min_length=None,            最小长度
    error_message=None,         忽略，错误信息使用 error_messages={'invalid': '...'}
 
EmailField(CharField)      
    ...
 
FileField(Field)
    allow_empty_file=False     是否允许空文件
    在上传文件的时候，要求request.method必须为POST，而且enctype=’multipart/form-data’
 
ImageField(FileField)      
    ...
    注：需要PIL模块，pip3 install Pillow
    以上两个字典使用时，需要注意两点：
        - form表单中 enctype="multipart/form-data"
        - view函数中 obj = MyForm(request.POST, request.FILES)
 
URLField(Field)
    ...
 
 
BooleanField(Field)  
    ...
 
NullBooleanField(BooleanField)
    ...
 
ChoiceField(Field)
    ...
    choices=(),                选项，如：choices = ((0,'上海'),(1,'北京'),)
    required=True,             是否必填
    widget=None,               插件，默认select插件
    label=None,                Label内容
    initial=None,              初始值
    help_text='',              帮助提示
 
 
ModelChoiceField(ChoiceField)
    ...                        django.forms.models.ModelChoiceField
    queryset,                  # 查询数据库中的数据
    empty_label="---------",   # 默认空显示内容
    to_field_name=None,        # HTML中value的值对应的字段
    limit_choices_to=None      # ModelForm中对queryset二次筛选
     
ModelMultipleChoiceField(ModelChoiceField)
    ...                        django.forms.models.ModelMultipleChoiceField
 
 
     
TypedChoiceField(ChoiceField)
    coerce = lambda val: val   对选中的值进行一次转换
    empty_value= ''            空值的默认值
 
MultipleChoiceField(ChoiceField)
    ...
 
TypedMultipleChoiceField(MultipleChoiceField)
    coerce = lambda val: val   对选中的每一个值进行一次转换
    empty_value= ''            空值的默认值
 
ComboField(Field)
    fields=()                  使用多个验证，如下：即验证最大长度20，又验证邮箱格式
                               fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])
 
MultiValueField(Field)
    PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用
 
SplitDateTimeField(MultiValueField)
    input_date_formats=None,   格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y']
    input_time_formats=None    格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M']
 
FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹
    required=True,
    widget=None,
    label=None,
    initial=None,
    help_text=''
 
GenericIPAddressField
    protocol='both',           both,ipv4,ipv6支持的IP格式
    unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用
 
SlugField(CharField)           数字，字母，下划线，减号（连字符）
    ...
 
UUIDField(CharField)           uuid类型

```



## form校验（三种）

### 1.使用正则

```python
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.validators import RegexValidator

class MyForm(Form):
    user = fields.CharField(
        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],

)
```

### 2.自己定义函数，注册到validations

```python
import re
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.exceptions import ValidationError
 
 
# 自定义验证规则
def mobile_validate(value):
    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')
    if not mobile_re.match(value):
        raise ValidationError('手机号码格式错误')
 
 
class PublishForm(Form):
 
 
    title = fields.CharField(max_length=20,
                            min_length=5,
                            error_messages={'required': '标题不能为空',
                                            'min_length': '标题最少为5个字符',
                                            'max_length': '标题最多为20个字符'},
                            widget=widgets.TextInput(attrs={'class': "form-control",
                                                          'placeholder': '标题5-20个字符'}))
 
 
    # 使用自定义验证规则
    phone = fields.CharField(validators=[mobile_validate, ],
                            error_messages={'required': '手机不能为空'},
                            widget=widgets.TextInput(attrs={'class': "form-control",
                                                          'placeholder': u'手机号码'}))
 
    email = fields.EmailField(required=False,
                            error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'},
                            widget=widgets.TextInput(attrs={'class': "form-control", 'placeholder': u'邮箱'}))
```

### 3.钩子函数

```python
#在form类定义方法，校验用户名和密码，局部钩子函数名称clean_<局部钩子要校验的字段名称>，自建局部钩子函数的返回值要和源码中的返回值一致，即都是返回校验成功后的数据，不成功要rasie ValidationError()错误，全局钩子函数同理，具体请参考源码is_valid函数的执行

    def clean_username(self):
        '''
        单独校验username字段，属于局部钩子
        '''

        value = self.cleaned_data.get("username")
        if "金 瓶 梅" in value:
            raise ValidationError("不符合社会主义核心价值观！")
        else:
            return value


    def clean(self):
        '''
        重写了基类Form中的clean方法，属于全局钩子
        '''
        pwd = self.cleaned_data.get("pwd")
        re_pwd = self.cleaned_data.get("re_pwd")

        if pwd != re_pwd:
            self.add_error("re_pwd", "两次输入的密码不一致！")
            # 两次输入的密码不一致
            raise ValidationError("两次输入的密码不一致！")
        else:
            return self.cleaned_data
```

## 插件

**主要是form中参数widget相关**

## 重点

1. 字段

   ​	-- 用于保存数据，及正则表达式等，为了方便，尽可将form中的字段名和models中的字段名对应相同

2. HTML插件

   ​	-- 即指参数widget，详见其源码

   ​	-- 只能生成form标签相关的html标签

3. 对于特殊的单选多选，数据源是否能够实时更新问题？？？

```python
'''
因为自定义的Form的子类中，字段为类属性，只在创建时初始化一次，之后的值都和程序开始运行时的数据一样，除非程序重启，否则以原代码是不能时时更新的，
'''
# 解决,将choices的赋值写早init函数中，推荐使用这一种
teacher = fields.IntegerField(min_value=1,
                                  label='教师',
                                  widget=widgets.Select(),
                                  error_messages={
                                      'require': '老师不能为空',
                                      'min_value': '老师输入超出范围',
                                  })

    def __init__(self, *args, **kwargs):
        super(ClassForm, self).__init__(*args, **kwargs)
        self.fields['teacher'].widget.choices = models.Teacher.objects.values_list('id', 'name')
        
# 第二种解决方法，使用django.forms.models中Model开头的field，其中的参数quertset及为models.Teacher.objects.values_list('id', 'name')，但是要更改对应models的__str__放法，此处及为teacher的__str__()方法




'''
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
'''
```

## Form组件扩展

### 1. 简单扩展

#### 利用form自带的正则扩展

### 2.基于源码的扩展

#### 扩展字段检测函数，即上述的局部钩子函数，只能对指定的字段检测判断

#### 全局钩子。检测整体字段

# django的序列化

```python
# 只有queryset[obj, obj]中是对象的，即是通过modesl.Teacher.objects.all()得到的数据，在转成字符串时，才需要用django的序列化,因为json模块只能对python的自己的数据类型进行序列化，并且在前端对应的ajax中，要反序列化后才能循环
from django.core import serializers
user_list = modesl.Teacher.objects.all()
ret['data'] = serializers.serilaize('json', user_list)
```



