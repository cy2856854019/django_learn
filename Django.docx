# 获取cookie： request.COOKIES[key]安装（ubuntu）django1.7及以上版本

	pip install django	(python2)
	pip3 install django	(python3)

# 创建项目

	django-admin.py startproject projectname(工程名)
	创建后，在当前目录将生成projectname文件夹， 其文件数结构如下：
		projectname
		├── manage.py
		└── projectname
			├── __init__.py
			├── settings.py
			├── urls.py
			└── wsgi.py
	注：
		manage.py
			一个实用的命令行工具，可以让你以各种方式与该django项目进行交互
		__init__.py
			一个空文件，告诉python该目录是一个python包
		settings.py
			该项目的配置
			setting中关于数据库ENGINE的设置
			MySQL (django.db.backends.mysql)
			PostGreSQL (django.db.backends.postgresql_psycopg2)
			Oracle (django.db.backends.oracle) and NoSQL DB
			MongoDB (django_mongodb_engine)
	
		urls.py
			该项目的url声明，一份由django驱动的网站"目录",项目创建的各个环节和要调用的函数
		wsgl.py
			一个兼容WSGI的web服务器的入口	
	
		diango-admin.py 是安装django之后的管理工具
		diango-admin.py和manage.py
		这两个文件代码和包含命令基本是一样的，只不过django-admin.py一般只用来创建项目，而manage.py用来管理创建好了的项目
	
	python3 manage.py startapp app_name或者django-admin.py startapp app_name 创建应用app(要先cd到当前项目目录)
	会在manage.py同级目录下生成
	├── app_name
	│   ├── admin.py	与后台相关
	│   ├── apps.py
	│   ├── __init__.py
	│   ├── migrations
	│   │   ├── __init__.py
	│   │   └── __pycache__
	│   ├── models.py 	类似scrapy的items
	│   ├── __pycache__
	│   ├── tests.py
	│   └── views.py 	具体要通过网址显示的视图
注意：
	新建的app要田添加到settings.py文件中，否则django就不能自动找到app中的模板文件(app_name/tenplates/模板文件)和静态文件(/app_name/static/静态文件)



一些命令：
	创建数据库表单 或 更改数据库表或字段
		python3 manage.py makemigrations
		python3 manage.py migrate
	上述两行命令会对app的models.py文件进行检测，自动发现更改并创建对应表单到数据库中
	

	python3 manage.py flush	清空数据库 只留下空表单
	
	python3 manage.py collectstatic 收集静态文件
	
	python3 manage.py createsuperuser 创建超级管理员
	python3 manage.py changepasswoord username 修改用户密码
	
	导出 导入数据
		python3 manage.py dumpdata app_name > app_name.json
		python3 manage.py loaddata app_name.json
	
	django项目环境终端
		python3 manage.py shell 
	
	数据库命令行
		python3 manage.py dbshell Django会自动进入在setting.py中设置的数据库，如果是mysql等，会要求输入数据库用户密码，然后可以直接执行数据库的sql语句
	python3 manage.py 可以看到详细的参数列表

# 启动

	python3 manage.py runserver 8000
	上面的8000为端口号。如果不说明，那么端口号默认为8000
	如果想要别的电脑也能访问 则要python3 manage.py runserver ip:port

# 操作

	在urls.py中修改代码，可以将URL与要操作的函数进行绑定
	详情见：
		http://www.runoob.com/django/django-first-app.html

# 常用库\函数等
​	from django.http import HttpResponse
​		HttpResponse 是用来向网页返回内容，如print一样，区别在与print输入到屏幕，HttpResponse输出到网页

# virtualenv（ubuntu安装步骤）
​		可以用virtualenv来管理多个开发环境
​	安装：
​		sudo pip3 install virtualenv virtualenvwrapper
​		修改 ~/.bashrc 结尾添加如下语句 （$HOME/.virtualenvs 要在自己创建 是virtualenv虚拟环境的路径）
​			export WORKON_HOME=$HOME/.virtualenvs
​			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 # 指定用python3
​			export PROJECT_HOME=/home/cy/eclipse-workspace_py/Django/virtualenvs # 工程路径
​			source /usr/local/bin/virtualenvwrapper.sh #virtualenv的执行脚本
​	常用命令：
​		mkvirtualenv zqxt : 创建运行环境zqxt
​		mkproject zqxt : 创建zqxt项目和运行环境zqxt
​		workon zqxt : 工作在zqxt环境
​		rmvirtualenv zqxt : 删除运行环境zqxt （在删除之前要关闭运行环境，deactivate）
​		lsvirtualenv : 列出可用的运行环境
​		lssitepackages : 列出当前环境安装的包

# settings.py详解

```python

import os
 
#向上找两级，获取基地址
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
 
SECRET_KEY = 'tt^-bhdmqd-^pet%puk*q58gcqg-g)9h+97!4m9aveddp_$%5e'
 
DEBUG = True
 
ALLOWED_HOSTS = []
 
#APP信息，自己新建的项目如果没有自动加入，可以再次手动加进去
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app01',
    'backend',
    'web',
]
 
#中间件配置
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # "app01.my_middlewares.AuthMiddleware",  #注意自己写的中间件，配置要写在系统中的后面
]
 
ROOT_URLCONF = 'myblog.urls'
 
#模板（HTML页面）路径相关配置
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
 
# #配置模板
# TEMPLATE_DIRS = (
#         os.path.join(BASE_DIR,'templates'),
# )
 
#网页服务网关协议消息
WSGI_APPLICATION = 'myblog.wsgi.application'
 
 
#原来默认的sqlite数据库
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
#     }
# }
 
#mysql数据库 同时需要设置__init__.py
# import pymysql
# pymysql.install_as_MySQLdb()
 
DATABASES = {
                'default': {
                    'ENGINE': 'django.db.backends.mysql',
                    'NAME':'myblog', #数据库名
                    'USER': 'root',
                    'PASSWORD': '',
                    'HOST': 'localhost',
                    'PORT': 3306,
                    }
                }
 
#认证相关
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
 
# 语言
LANGUAGE_CODE = 'zh-hans'  # 主要针对admin页面
# 时间
TIME_ZONE = 'Asia/Shanghai'
 
USE_I18N = True
USE_L10N = True
 
#时区设置
USE_TZ = False
 
#静态文件
STATIC_URL = '/static/'  # 静态文件别名
STATICFILES_DIRS=(
    os.path.join(BASE_DIR,'static'),  #主文件下静态文件
)
 
# 与用户上传相关的配置
#路由urls.py中也需要配置
"""
# media配置:
from django.urls import path,re_path
from django.views.static import serve
from django.conf import settings
 
urlpatterns = [
    re_path(r"media/(?P<path>.*)$",serve,{"document_root":settings.MEDIA_ROOT}),
]
"""
 
MEDIA_ROOT=os.path.join(BASE_DIR,"media")
MEDIA_URL="/media/"
 
# 引用Django自带的User表，继承使用时需要设置
#如果数据库中的UserInfo(用户表)继承django内置AbstractUser
#model需导入 from django.contrib.auth.models import AbstractUser
AUTH_USER_MODEL="app01.UserInfo"  #应用名.UserInfo
 
# 自定义配置登陆验证返回路径
LOGIN_URL="/login/"
LOGIN_REDIRECT_URL = '/'
LOGOUT_URL = '/logout/'
 
 
 
 
#
EMAIL_HOST = 'smtp.exmail.qq.com'  # 如果是 163 改成 smtp.163.com
EMAIL_PORT = 465
EMAIL_HOST_USER = ''           # 帐号
EMAIL_HOST_PASSWORD = ''  # 密码
# DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
EMAIL_USE_SSL = True
 
#session存储的相关配置
# Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session表中。提供了5种类型的Session
"""
#1.数据库
SESSION_ENGINE = 'django.contrib.sessions.backends.db'  # 引擎（默认）
#2.缓存
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎
SESSION_CACHE_ALIAS = 'default'
# 要配合Django缓存配置
# 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置
#3.文件
SESSION_ENGINE = 'django.contrib.sessions.backends.file'    # 引擎
SESSION_FILE_PATH = None
# 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()
#4.缓存+数据库
SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'        # 引擎
#5.加密cookie 基本没有用
SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'   # 引擎
"""
 
# SESSION_COOKIE_NAME = "sessionid"                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）
# SESSION_COOKIE_PATH = "/"                               # Session的cookie保存的路径（默认）
# SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）
# SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）
# SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）
# SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）
# SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）
# SESSION_SAVE_EVERY_REQUEST = True        # （每次刷新更新时间） 是否每次请求都保存Session，默认修改之后才保存（默认）
 
SESSION_COOKIE_AGE = 60 * 60 * 24
SESSION_SAVE_EVERY_REQUEST = True
 
#打印日志到屏幕
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}


```



# 静态文件

## 引入

1. ```HTML
   <script src="/static/jquery-3.3.1.min.js"></script>
   ```

2. ```HTML
   现在head标签中加入下一句{% load staticfiles %}
   然后用下句代替法一
   <script src='{% static "jquery-3.3.1.min.js" %}'></script>
   推荐使用法2
   ```

# 视图

## 视图函数常用函数/属性

### request相关

request.method

​	判断是get方式或者post等

request.path

​	请求页面的全路径，不包括域名

request.get_full_path()

​	请求页面的全路径，及参数

request.GET/request.POST

### 网页渲染

render(推荐使用,两者效果类似,render_toresponse参数中不用加request,其他一样,推荐使用render)

render_to_response

### 网页跳转

redirect 参数是路径(url)

# urls.py

```python
from django.urls import path, re_path, reverse
from . import views

urlpatterns = [
    re_path(r'video-(?P<classification_id>(\d+))-(?P<level_id>(\d+))-(?P<status>([0-2])).html',
            views.video),
    re_path(r'video2-(?P<direction_id>(\d+))-(?P<classification_id>(\d+))-(?P<level_id>(\d+))-(?P<status>([0-2])).html',
            views.video2, name='video2'),
    path('img_video', views.img_video),
]
'''
用url对应的别名（如name='video2'）反向生成url
 re_path(r'video2-(?P<direction_id>(\d+)).html',
            views.video2, name='video2'),
            在html中， {% url 'video2' direction_id=1 %}  => video2-1.html;
            在py代码中, reverse('video2', kwargs={'direction_id':1}) => video2-1.html;
            
path(r'video2-(\d+).html',
            views.video2, name='video2'),
            在html中， {% url 'video2' 1 %}  => video2-1.html;
            在py代码中, reverse('video2', args=(1,)) => video2-1.html;
'''

```



# 模板

## 模板语法

**变量用{{}}双大括号引用,功能类的,如循环 判断等用{% %}引用**

1. 列表，字典，类的实例的使用
2. 循环：迭代显示列表，字典等中的内容
3. 条件判断：判断是否显示该内容，比如判断是手机访问，还是电脑访问，给出不一样的代码。
4. **标签**：for，if 这样的功能都是标签。
5. **过滤器**：管道符号后面的功能，比如{{ var**|**length }}，求变量长度的 length 就是一个过滤器。

### 变量

用{{}}双大括号来引用变量

{{var_name}}

#### Template和Context对象

#### 万能的句点符(深度变量的查找)

#### 变量的过滤器(filter)

语法格式:  {{obj|filter:param}} obj是变量,filter写对应的过滤器函数,param是函数的参数,注意:左右不要有空格,|是管道符

**filter常用函数**

1. **add** 给变量加上相应的值
2. **addslashes** 给变量中的引号前加上斜线
3. **capfirst** 将首字母大写
4. **cut** 从字符串中移除指定的字符
5. **date** 格式化日期字符串
6. **default** 如果是false,就替换成设置的默认值,否则就用本来的值
7. **default_if_noe** 如果是None,就替换成设置的默认值,否则就使用本来的值

### 标签

{% 标签 %}

```html
<!--if-->
{% if num == 0 %}
	0
{% elif num == 1 %}
	1
{% else num == 0 %}
	else
{% endif %}

<!--for-->
{% for item in items %}
	<h1>{{ item }}</h1>
	<p>{{ forloop.counter }}:{{ item }}</p>
{% endfor %}
<!--
forloop.counter 表示循环的次数,从1开始计数,第一次循环设为1
forloop.counter0 类似forloop.counter,但是forloop.counter0从0开始计数,第一次循环为0
forloop.revcounter/forloop.revcounter0
forloop.first 当第一次循环时值为True,在特殊情况下很有用

forloop变量只能在循环中得到,当模板解析器到达{{% endfor %}}时,forloop就消失了
如果你的模板context中已经包含了一个叫forloop的变量,Django会用{% for %}标签替代它
Django会在for标签的块中覆盖你定义的forloop变量的值
在其他非循环的地方,自定义的forloop变量仍然有用
-->

<!--csrf_token 用于生成crsf_token标签,用于防止跨站攻击验证,设置该项后,在views.py中调用的render_to_response方法不会生效
在某个post请求第一次提交时,要加上该标签,不然安全验证不能通过,实际的显示作用是django将该标签渲染成一个带有name和value的input标签,只有有了该name value键值对,才能通过验证
-->
{% csrf_token %}

<!--empty-->
{% empty %}

<!--url 
后跟一个url或者路径,引用路由配置的地址
-->
{{% url %}}

<!--with
用更简单的变量名代替复杂的变量名
-->
{% with total=dafafafadfafadfasdfas %}
{{total}}<!--用total代替后面的数据,带仅限于该with标签内有效-->
{% endwith %}

<!--load
加载标签库
-->
{% load %}

<!--verbatim
禁止render
-->
{% verbatim %}
	{{ hello }}
{% endverbatim %}
```

### 自定义filter(自定义filter函数)

1. 在app中创建templatetags模块(必须有)
2. 在上述模块下创建任意py文件,代码类似如下:

```python
from django import template
from django.utils.safestring import mark_safe

'''
register  的名字是固定的,不可改变成别的名字
'''
register = template.Library()

'''
filter函数只能传入两个函数,第一个函数默认是filter修饰的变量,第二个参数才是filter, 如:<h1>{{ x|filter_multi:5 }}</h1>,x是v1,5是v2
filter可以用在if等语句中,simple_tag不可以
'''
@register.filter 
def filter_multi(v1, v2):
    return v1 * v2
'''
simple_tag是用register.simple_tag装饰,且参数不限个数,用{%  simple_tag %}调用
<h1>{% simple_tag_multi x y z %}</h1>
'''
@register.simple_tag
def simple_tag_multi(x, y, z):
    return x*y*z
```

3. 在使用自定义的filter或者自定义的simple_tag之前,要在html文件中用load导入之前创建的py文件,{% load myTag %}
4. 自定义simple_tag和自定义filter类似,不过使用方法不同

### extends 模板继承

继承的html中，所有的block块都是灵活的，可以被修改

#### 使用

1. 子模板第一行以extends语法开头

   如： { extends "base.html"} ，表示继承base.html

2. 父模板中的block标签块都可以被修改

3. 不允许同一个模板中出现重名的block

### include

使用：

1. 使用前要导入 ,{% load staticfiles %},导入后就可以使用include标签
2. {include "home.html" }

# ORM(object relational mapping)

## win平台django上使用mysql的坑（python manage.py makemigrations python manage.py migrate）

1. django默认是使用MySQLdb，但是python3不支持，需要在setting.py同级的init.py文件中加入如下两句：

   ```python
   import pymysql
   pymysql.install_as_MySQLdb()
   ```

2. django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None

   解决办法：

   找到Python安装路劲下的Python36-32\Lib\site-packages\django\db\backends\mysql\base.py文件

   将文件中的如下代码注释

   ```python
   if version < (1, 3, 3):
   
   	raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)
   ```

3. django执行python manage.py makemigrations 时报错AttributeError: 'str' object has no attribute 'decode'

   解决：

   ​	将operations,py文件的

   ​	query = query.decode(errors='replace') 中的decode改成encode

4. 再执行

   python manage.py makemigrations + （app_name）
   python manage.py migrate

   创建表



## **数据库接口**相关的接口（QuerySet API)

**models.py中的**

​	**类 对应 数据库的表**

​	**类对象 对应 数据库该表的一条数据**

​	**类的属性 对应 该表中的字段**

### QuerySet 创建对象的方法

```python
from blog.models imort Blog
# 法一
b = Blog(name='python基础', author='cy')
b.save()# 用此法创建数据对象，必须要调用save方法后才会在数据库里生成数据
# 法二
Blog.objects.create(name='python基础', author='cy')
# 法三
b = Blog()
b.name = 'python基础'
b.author = 'cy'
# 法四,尝试获取，不存在则创建，可以防止重复创建
Blog.objects.get_or_create(name='python基础', author='cy')
'''
前三种方法返回的都是对应的object，
最后一种方法返回是一个元组，(object,True/False)，创建时返回True,已经存在返回False
'''
```

### QuerySet 对象的获取

```python
# 查询所有 返回列表
Blog.objects.all() 
# 切片操作
Blog.objects.all()[:10]
# 获取一条，多条会报错，返回的是一条
Blog.objects.get(author='cy')
# filter 筛选符合条件的,返回的是set
Blog.objects.filter(author='cy')
# 等于Person.objects.filter(name__exact="abc") 名称严格等于 "abc" 的人
Blog.objects.filter(name="abc") 
# 名称为 abc 但是不区分大小写，可以找到 ABC, Abc, aBC，这些都符合条件
Blog.objects.filter(name__iexact="abc") 
# 名称中包含 "abc"的人
Blog.objects.filter(name__contains="abc") 
#名称中包含 "abc"，且abc不区分大小写
Blog.objects.filter(name__icontains="abc") 
# 正则表达式查询
Blog.objects.filter(name__regex="^abc")
# 正则表达式不区分大小写
Blog.objects.filter(name__iregex="^abc")

# filter是找出满足条件的，当然也有排除符合某条件的
# 排除包含 WZ 的Person对象
Blog.objects.exclude(name__contains="WZ") 
# 找出名称含有abc, 但是排除年龄是23岁的
Blog.objects.filter(name__contains="abc").exclude(age=23) 

```

### QuerySet 对象的修改

修改推荐使用update方法，效率高

```python
Blog.objects.filter(author='cy').update(author='cy123')

```

### QuerySet 对象的删除

```python
# 调用delete方法
Blog.objects.filter(author='cy').delete()
```

QuerySet对象的常用方法，详见https://docs.djangoproject.com/en/dev/ref/models/querysets/

### QuerySet 对象转成字典

```python
'''
在将QuerySet对象转换为字典时使用dict()方法和to_dict()都不可以，于是采用了 model_to_dict(user)方法
'''
from django.forms.models import model_to_dict
```





## 一对多

如：

​	**书与出版社的关系:**

​		一个出版社可以出版多本书，故出版社是一，书是多，

​		外键一般建在多的一方

​		

### 一对多 查询 （基于QuerySet对象）

```python
class Book(models.Model):
    name = models.CharField(max_length=20)
    price = models.IntegerField()
    pub_date = models.DateField()
    author = models.CharField(max_length=40, null=True)
    #author = models.ForeignKey('Author')
    publish = models.ForeignKey('Publish')


class Publish(models.Model):
    name = models.CharField(max_length=20)
    place = models.CharField(max_length=20)
'''
publish是Book的外键

b1 = Book.objects.filter(author='cy')[0]
p1 = b1.publish
p1.name

p2 = Publish.objects.get(name='人民出版社') #不建议用get 没数据会报错，用.filter().first()代替
p2.book_set.all().values('author')
'''
```

## 一对多 查询 （基于双下划线查询,双下划线用在filter和values中）

```python
Book.objects.filter(publish__name='北京出版社').values('name', 'price')
Book.objects.filter(name='基础').values('publish__name')
print(Book.objects.filter(publish__name='人民出版社').values('author__name'))

Publish.objects.filter(book__name='基础').values('name')
```



 

### 一对多 添加

```python
# 法一
Book.objects.create(name='基础', price=20, author_id=1, pub_date='2017-12-12', publish_id=1)
# 法二
p1 = Publish(name='人民出版社', city='北京')
p1.save()

num = random.randint(1, 100)
a1 = Author.objects.create(name='cy'+str(num), age=18)

Book.objects.create(name='基础', price=20, author=a1, pub_date='2017-12-12', publish=p1)
# 法三
p1 = Publish.objects.create(name='人民出版社')[0]
Book.objects.create(name='基础', price=20, author_id=1, pub_date='2017-12-12', publish=p1)
```

## 一对一（OneToOneField）

```python
class Person(models.Model):
    name = models.CharField(max_length=20)


class PersonDetail(models.Model):
    age = models.IntegerField(10)
    email = models.EmailField()
　　# person = models.ForeignKey(Person, unique=True)  
　　person = models.OneToOneField(Person)
    
    
def one(request):
　　# 查询alex的用户信息
    # 前向查询
    ret = models.PersonDetail.objects.get(id=1) #  ret = models.PersonDetail.objects.get(id=models.Person.objects.get(name='alex').id)
　　# 这里的person是表中的关联外键的字段并非类名字
    print(ret.person)  # Person object 封装的Person对象
    print(ret.person.name, ret.age, ret.email)

　　# 查询alex的用户信息
    # 反向查询
    obj = models.Person.objects.get(name='alex')
    # persondetail 类名字的小写
    print(obj.persondetail)  # PersonDetail object
    print(obj.name, obj.persondetail.email, obj.persondetail.age)
    return HttpResponse('OK')
'''
“反向”查询中有所不同。一对一关系中的关联模型同样具有一个管理器对象，但是该管理器表示一个单一的对象而不是对象的集合。

一对一的方式原理上是  ForeignKey + unique=True。但是既然是外键 那么一对多的反向查询方式应该和一对一的反向查询方式相同，而实际上不是这样的，一对一的反向查询方式是 obj.persondetail   对象.类名小写 ，没有_set。
'''
```



## 多对多

**多对多关系必须依赖第三张表**

**多对多关系才会创建第三张表**

**有外键时，才会创建一个后缀为_id的字段**

**跨表查询用__**

如：book_author关系,要依赖于字段为book_id和author_id的第三张表

```python
class Book(models.Model):
    name = models.CharField(max_length=20)
    price = models.IntegerField()
    pub_date = models.DateField()
    # author = models.ForeignKey('Author', on_delete=None, null=False)
    publish = models.ForeignKey('Publish', on_delete=None, null=True)
    author = models.ManyToManyField('Author')  # 多对多


class Publish(models.Model):
    name = models.CharField(max_length=20)
    city = models.CharField(max_length=20)


class Author(models.Model):
    name = models.CharField(max_length=32)
    age = models.IntegerField()

    
'''
多对多关系中，由于一本书可以对应多个作者，故Book.objects.get(id=3).author得到的是QuerySet
'''
Book.objects.get(id=3).author.all().values('name', 'age')# id为3的书的作者的name age，返回的queryset对象中是存放了name、age的字典，<QuerySet [{'id': 2, 'class_name': 'django二班'}, {'id': 7, 'class_name': 'django三班'}, {'id': 8, 'class_name': 'django一班'}, {'id': 9, 'class_name': 'django四班'}]>
Book.objects.get(id=3).author.all().values_list('name', 'age')# id为3的书的作者的name age，返回的queryset对象中是存放了name、age的元组,<QuerySet [(2, 'django二班'), (7, 'django三班'), (8, 'django一班'), (9, 'django四班')]>

# 逆向查找，用类名(类名的小写)_set，前提是两者通过外键关联，也可通过设置外键中的参数related_name来替代类名_set
Author.objects.get(id=2).book_set.all() # id为2的作者出的所有书的信息

# 常用与性能相关的查询
# select_related, 跨表查询,一次夺标查询获取所有的数据
models.Book.objects.select_related('ut')
# ut是一对多的外键，上句效果类似如下的sql语句：
# select * from Book join ut on Bool.ut_id == ut.id

# prefecth_related，也是跨表查询，相当于把上述sql语句拆分两条sql语句执行
```

### 多对多添加

```python
b1 = Book.objects.get(id=3)
a1 = Author.objects.all()
b1.author.add(*a1)
b1.author.add([2, 3])#2 3 为作者的id
b1.author.set([1, 2, 3]) # 重置
```



### 多对多删除

```python
b1 = Book.objects.get(id=3)
a1 = Author.objects.all()
b1.author.remove(*a1) # 全删除
b1.author.remove(1)# 删除书b1中id为1的作者
b1.author.clear()  
```

## 外键关联删除

## models参数详解

```python
# 通用参数，在所有的field（charfield interfield等）中都有的参数
null # 数据库中该字段是否可为空
db_column # 数据库中该字段的名称
default # 数据库中字段的默认值

primary_key # 是否为主键，唯一，不可为空
db_index # 数据库中是否可以建立索引
unique # 数据库中是否可以建立唯一索引

unipe_for_data # 数据库中字段（日期）部分是否可以建立唯一索引、
unipe_for_month # 数据库中字段（月）部分是否可以建立唯一索引
unipe_for_year # 数据库中字段（年）部分是否可以建立唯一索引

verbose_name # admin中显示的字段名称
blank # admin中是否允许用户输入为空
editable # admin中是否可以编辑
help_text # admin中该字段的提示信息
choices # admin中显示选择框的内容，用不动的数据放在内存中从而避免跨表操作，？？？不懂

error_message # 自定义错误信息，和form组件的类似
validators # 自定义验证

# 特殊的参数，
# 一对多 外键
ForeginKey
	to， # 要进行关联的表明
    to_field, # 要关联的表中的字段名称
    on_delete, # 当删除关联表中的数据时，当前表与其关联的数据的行为
    	'''
    		- models.CASCADE 删除关联数据，与之关联的数据也删除
    		- models.DO_NOTHING 删除关联数据， 报错IntegrityError
    		- models.PROTECT 删除关联数据 报错ProtectedError
    		- models.SET_NULL 删除关联数据 与之关联的值设置为null(前提ForeginKey字段要设置为可空)
    		- models.SET_DEFAULT，删除关联数据 与之关联的值设置为默认值(前提ForeginKey字段要设置了默认值)
    		- models.SET 删除关联数据
    			a. 与之关联的值设置为指定值，models.SET(指定值)
    			b. 与之关联的值设置为可执行对象的返回值，models.SET(可执行对象)
    	'''
    related_name, # 反向操作时，使用的字段名，用于替代 表名_set
    related_query_name, # 反向操作时，使用的连接前缀，用于替换 表名
    
    limit_choices_to， # 在admin或ModelForm中显示关联数据时，提供的条件，如： limit_choices_to = {'id__gt':1} id大于1
    parent_link, # 在admin中显示是否关联外键
    
    db_constraint, # 是否在数据库中创建外键约束


oneToOneField 
	# 继承于Foreginkey ，比外键多一个唯一索引，即外键_id是唯一的

# 多对多
to
related_name
related_query_name
limit_choices_to
synmetrical, # 仅使用于多对多关联时，synmetrical用于指定内部是够创建反向操作的字段，只用于自关联
through, # 自定义第三张表时， 使用字段用于指定第三张表是那个关系表
through_field, #自定义第三张表时，使用该字段用于指定关系表中那些字段多对多关系表 
db_constraint, # 是否在数据库中创建外键约束
db_table, # 默认创建第三张表时，数据库中表的名称

#第三张表可以通过ManyToMany创建，但是创建后字段个数不能改变，也可手动创建第三张变，此时可以自定义其他字段，但是要加联合约束，也可两者结合（不推荐）

# 多对多的自关联（如互粉，用户id自关联）， 一对多的自关联（如评论，评论的主键id和评论的父id，即该条评论是回复的哪条评论，是新的评论，可将评论的父id字段赋值为默认）
class User(models.Model):
    d = models.ManyToManyField('User', related_name='b')
    # 自关联时，一定要加上related_name，便于反向查找


class Cart(models.Model):
    user = models.ForeignKey(
        MyUser,
        verbose_name="用户", # 在admin后台中显示的字段名称
    )
    goods = models.ForeignKey(
        Goods,
        verbose_name="商品"
    )
    num = models.IntegerField(
        verbose_name="商品数量",
        # 最大、最小值， from django.core.validators import MaxValueValidator, MinValueValidator
        validators=[MaxValueValidator(100), MinValueValidator(1)], 
    )
    is_select = models.BooleanField(
        default=True,
        verbose_name="选中状态"
    )
 
    class Meta:
        # 联合约束   其中goods和user不能重复
        unique_together = ["goods", "user"]
        # 联合索引
        index_together = ["user", "goods"]
        
        # 数据库中对应表的名称，不写默认为<app_name>_<model_name>，该处即为slideshow_SlideShow
         # db_table = 'SlideShow'
         # 在admin中显示的SlideShow的别名，如不设置verbose_name_plural，则admin中显示 轮播图s
         verbose_name = '轮播图'
         # 在admin中显示的SlideShow的别名,复数时，此处表明单复数都是一样显示 轮播图
         verbose_name_plural = verbose_name    
```

# admin

## 创建管理员账号

```python
python manage.py createsuperuser # 执行该命令后，按照提示创建管理员账号密码
```

创建管理员账号后，python manage.py runserver port 运行服务；

浏览器访问url+admin，即可进入django自带的原始后台管理；

进入后台后，可进行多种操作，如添加管理员(添加的新管理员要加入staff后才能登录)

1. 进入到app的同级目录下,修改admin.py（没有admim.py则先创建再修改）

2. 在admin.py中注册数据库的表单

   ```python
   from django.contrib import admin
   
   # Register your models here.
   from . import models
   
   admin.site.register(models.Book)
   admin.site.register(models.Author)
   admin.site.register(models.Publish)
   ```

## Django admin的配置

```python
class BookAdmin(admin.ModelAdmin):
    # 在admin后台中显示的字段，不可加上多对多关系
    list_display = ('id', 'name', 'price', 'pub_date')
    # 在admin后台中可编辑的字段
    list_editable = ('price',)
    # 作者可搜索，水平显示
    filter_horizontal = ('author',)
    # 每页显示几个
    list_per_page = 3
    # 按照什么字段过滤
    list_filter = ('pub_date', 'publish')
    # 用 name 属性排序， '-' 表示倒序排列
    ordering = ('-name',) 
    # 设置搜索框中允许搜索的字段
    search_fields =('name', 'date') 
    # 添加一个 action, 需要定义函数 
    actions = [add_one_copy,] add_one_copy
    
admin.site.site_header = 'Test Management' # 设置标题
admin.site.site_title = 'Test Management' # 设置标题
# 将定制的BookAdmin绑定到Book上，再注册
admin.site.register(models.Book, BookAdmin)
admin.site.register(models.Author)
admin.site.register(models.Publish)
'''
#方式一：装饰器
@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = ['name','nickname','email']

#方式二：参数传入
# admin.site.register(Book,BookAdmin)
'''
```

# cookie session

## cookie

```python
# cookie是保存在客户端（浏览器）中的键值对，以文件格式保存在本地
获取cookie： request.COOKIES[key]
设置cookie： response.set_cookie（key, value)
```

## session

```python
#session默认在服务器保存 15 天，session可以保存在数据库、文件或者缓存中去
获取session： request.session(key)
设置session: request.session[key] = value
删除session: del request_session[key]# 这个删除其实就是服务器数据库的session_data更新为一个其他的值，并没有立即删除
request.session.set_expiry(value)# 设置session的有效时间
# value为整数时，表示秒数
# 为datetime或timedelta时,会在该value之后失效
# 为0时，用户关闭浏览器session会立即失效
# 为None时，session会依赖全局session失效策略
```

## cookie和session的区别

1. cookie是保存在浏览器端的键值对，session是保存在服务端的键值对
2. cookie的存储量有限，一般不超过4096字节，且安全性不高，session存储量比较大，安全性较高
3. cookie和session使用时，cookie中的键sessionid的值，对应的是该session中对应的值



# django的生命周期

## 请求的生命周期

指当用户点从浏览器点击时，django后台经历的流程

1. 构造请求字符串(请求头+分隔符（\r\n\r\n）+请求体)，发送http请求

2. 服务端接受请求，在路由分发中从上往下查找，找不到则报404

3. 执行所查找的路由对应的函数（对于cbv来说， 找到对应的class后去执行django的dispatch方法，找到后去执行对应的方法）

   cbv, url->类,该类要继承django.view，而该view在base.py中，；fbv, url->函数

4. 业务处理

   - 根据个人需求自定
   - 操作数据库
     - 可以用原生的SQL
     - 用django的ORM
   - 响应内容
     - 响应头
     - 响应体

# 提交数据

## Form表单

页面会刷新

## Ajax

悄悄的向后台发一个请求

本质是通过创建的XMLHttpRequest对象操作

```html
$.ajax({
	url: '要提交的url，类似form表单中的action属性'，
	type: 'POST'/'GET',
	data: {}, //包含请求体的字典，key可加引号也可不加
	datatype: 'JSON'（将返回内容序列化）/text/html/xml/jsonp(一种机制，通过后面的原理得知，只能发送get)
    //traditional:true,// 当data中的value为list时（value不能为dict类型，想为dict时要用json转成字符串然后再发送），需要设置这个选项为true
	success:function(arg){
		//回调函数，arg是服务端返回的信息
		console.log(arg)
	}
	error:function(){

	}
})


//$('# form表单的id').serialize()  可以将from表单里的数据全部提交

```

### 1. jQuery Ajax

### 2. 不依赖jQuery的Ajax发送GET请求

### 3. 不依赖jQuery的Ajax发送POST请求

### 4. '伪'Ajax(iframe标签+form表单)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ajax1</title>
    <style>
        .btn {
            display: inline-block;
            padding: 15px 10px;
            background-color: yellow;
        }
    </style>
</head>
<body>
<h1>Ajax全套</h1>
<h3>jQuery Ajax</h3>
<div>
    <a href="javascript:void;" class="btn" onclick="ajaxSubmit1();">ajax1</a>
</div>
<h3>不依赖jQuery的Ajax发送GET请求</h3>
<div>
    <a href="javascript:void;" class="btn" onclick="ajaxSubmit2();">ajax2</a>
</div>
<h3>不依赖jQuery的Ajax发送POST请求</h3>
<div>
    <a href="javascript:void;" class="btn" onclick="ajaxSubmit3();">ajax3</a>
</div>
<h3>'伪'Ajax(iframe标签+form表单)</h3>
<div>
    <form id="form1" target="iframe1" method="post">//需要将form的target属性 设置为iframe的name属性，才能将form从服务器得到的响应渲染到iframe中
        <input type="text" name="url" value="请输入url"/>
        <a id="submit" href="javascript:void;" class="btn" onclick="ajaxSubmit4();">ajax4</a>
        {#        <input id="submit" type="submit" value="ajax4"/>#}
    </form>
    <iframe id="iframe1" name="iframe1"></iframe>
</div>

<script src="/static/js/jquery-3.1.1.js"></script>
<script>
    function ajaxSubmit1() {
        $.ajax({
            url: '/ajax_demo/ajax1/',
            type: 'POST',
            data: {'d': 123},
            success: function (arg) {
                console.log(arg)
            }
        })
    }

    function ajaxSubmit2() {
        var xhr = new XMLHttpRequest(); //创建XMLHttpRequest对象，在js中创建对象必须加new关键字
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) { //4表示接受完毕服务器返回的数据
                console.log(xhr.responseText);
            }
        };
        xhr.open('GET', '/ajax_demo/ajax1/'); //以何种方式（post/get）和某个url创建连接

        xhr.send(null); //发送请求, 当为post请求时，将null改成post的数据
    }

    function ajaxSubmit3() {
        var xhr = new XMLHttpRequest(); //创建XMLHttpRequest对象，在js中创建对象必须加new关键字
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) { //4表示接受完毕服务器返回的数据
                console.log(xhr.responseText);
            }
        };
        xhr.open('POST', '/ajax_demo/ajax1/'); //以何种方式（post/get）和某个url创建连接
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); // 设置请求头，要和django内置的请求头一致,key, value
        xhr.send('p=123'); //发送请求, 当为post请求时，将null改成post的数据
    }

    function ajaxSubmit4() {
        document.getElementById('iframe1').onload = submitForm;
        document.getElementById('form1').submit();

        function submitForm() {
            var html = this.contentWindow.document.body.innerHTML;
            console.log(html);
            var data = JSON.parse(html);
            alert(data.url)
        }
    }
</script>
</body>
</html>
```

## Ajax上传文件（除了伪ajax外，其他都依赖于FormData）

### 1. jQuery Ajax

### 2. 不依赖jQuery的Ajax发送GET请求

### 3. 不依赖jQuery的Ajax发送POST请求

### 4. '伪'Ajax(iframe标签+form表单)

## JSONP 跨域Ajax

### 原理

1. 在head标签中生成一个script标签，将该script标签的src属性改成要发送请求的url**（所有有src属性的标签都可以跨域请求，如iframe img等）**，在显示后立马在删除掉这个script标签，因此前端代码中会出现一下script标签然后立马消失，

2. 通过JSONP从服务器得到的响应数据是直接返回给script，故要按照javascript的格式，如返回HttpResponse('func("JSONP")')，即用接收响应数据的js中的func函数处理返回的数据

3. ### 原理示例

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>ajax1</title>
       <style>
           .btn {
               display: inline-block;
               padding: 15px 10px;
               background-color: yellow;
           }
       </style>
   </head>
   <body>
   <h3>JSONP</h3>
   <input type="button" value="send" onclick="submitJsonp();"/>
   <input type="button" value="send_ajax(跨域)" onclick="submitJsonp1();"/>
   
   <script src="/static/js/jquery-3.1.1.js"></script>
   <script>
       function submitJsonp() {
           var tag = document.createElement('script'); //创建script标签
           tag.src = 'http://127.0.0.1:9999/app1/jsonp/'; //设置src属性
           document.head.appendChild(tag); // 将上述script标签添加到head中
           document.head.removeChild(tag); // 将上述script标签从head中删除
       }
   
       // 设置本地回调函数处理从http://127.0.0.1:9999/app1/jsonp/返回的响应，因为示例中返回的响应为HttpResponse('func("JSON");')，故此处的回调函数为func，请根据实际情况写回调函数
       function jsonpCallback(arg) {
           alert(arg);
       }
       // 使用封装好的JSONP，通过jsonp和jsonpCallback即可自己规定回调函数的名称，在后端获取函数名称使用即可, submitJsonp + jsonpCallback 效果 同submitJsonp1 + jsonpCallback，不同的是前者需要请求的接口http://127.0.0.1:9999/app1/jsonp/返回的函数定死必须和前端一样为jsonpCallback，后者，只要通过func_name=request.GET.get('jsonpCallback')即可获取前端传入的回调函数名
       function submitJsonp1() {
           $.ajax({
               url: 'http://127.0.0.1:9999/app1/jsonp/',
               type: 'GET',
               dataType: 'JSONP',
               jsonp: 'callback', // 相当于http://127.0.0.1:9999/app1/jsonp/?callback,即给url设置参数名
               jsonpCallback: 'jsonpCallback',// 相当于http://127.0.0.1:9999/app1/jsonp/?callback=func，即给url设置参数值
           })
       }
   </script>
   </body>
   </html>
   ```

   

### 场景

由于浏览器的同源策略（所有浏览器都有），XMLHttpRequest要遵循这个同源策略

## CORS（跨站资源共享）也可处理浏览器的同源策略

```python
# 后端
# 注： 谁作为服务端(即呗请求端), 则Access-Control-Allow-Origin头设置在谁的后端接口中
def jsonp(request):
    response = HttpResponse('func("jsonp_test")')
    response["Access-Control-Allow-Origin"] = '*'
    return response
```

### 对象的django实现

```python
# 在对象app下创建中间件文件middlewares.py， 写入如下内容
from django.utils.deprecation import MiddlewareMixin
class MyMiddleware(MiddlewareMixin):
    def process_response(self, request, response):
        response['Access-Control-Allow-Origin'] = '*'
        return response
 # 在settings.py的MIDDLEWARE加上
MIDDLEWARE = [
    ......
    'app_51CTO.middlewares.MyMiddleware', # app_51CTO为app的名称
    ......
]

```

# 分页

## django的内置分页

```python
'''
内置分页主要是两个对象，Paginator、Page, 可以通过这两个对象得到当前页、上一页、下一页、是否有下一页、是否有上一页、总页数等
'''
```

## 扩展django的内置分页

**本质就是集成内置分页进行优化**

详见练习项目django_form

## 自定义分页

# Form组件

## 作用

1. 对用户提交的数据进行检验
2. 生成html代码（生成错误信息相关的html代码或者输入框相关的html代码等）

## 使用

1. 创建类，继承django.forms.Form
2. 在类中创建要输入的字段
3. 根据请求类型的不同，返回不同的html代码（该html代码可以由form组件生成）

## form组件常用字段及参数详解

```python
'''
创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;
initial
'''
# 初始值，input框里面的初始值。

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三"  # 设置默认值
    )
    pwd = forms.CharField(min_length=6, label="密码")

error_messages

# 重写错误信息。

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三",
        error_messages={
            "required": "不能为空",
            "invalid": "格式错误",
            "min_length": "用户名最短8位"
        }
    )
    pwd = forms.CharField(min_length=6, label="密码")

password

class LoginForm(forms.Form):
    ...
    pwd = forms.CharField(
        min_length=6,
        label="密码",
        widget=forms.widgets.PasswordInput(attrs={'class': 'c1'}, render_value=True)
    )

radioSelect

# 单radio值为字符串

class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label="用户名",
        initial="张三",
        error_messages={
            "required": "不能为空",
            "invalid": "格式错误",
            "min_length": "用户名最短8位"
        }
    )
    pwd = forms.CharField(min_length=6, label="密码")
    gender = forms.fields.ChoiceField(
        choices=((1, "男"), (2, "女"), (3, "保密")),
        label="性别",
        initial=3,
        widget=forms.widgets.RadioSelect
    )

# 单选Select

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.ChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),
        label="爱好",
        initial=3,
        widget=forms.widgets.Select
    )

# 多选Select

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"), ),
        label="爱好",
        initial=[1, 3],
        widget=forms.widgets.SelectMultiple
    )

# 单选checkbox

class LoginForm(forms.Form):
    ...
    keep = forms.fields.ChoiceField(
        label="是否记住密码",
        initial="checked",
        widget=forms.widgets.CheckboxInput
    )

# 多选checkbox

class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, "篮球"), (2, "足球"), (3, "双色球"),),
        label="爱好",
        initial=[1, 3],
        widget=forms.widgets.CheckboxSelectMultiple
    )

# 关于choice的注意事项：

在使用选择标签时，需要注意choices的选项可以从数据库中获取，但是由于是静态字段 ***获取的值无法实时更新***，那么需要自定义构造方法从而达到此目的。

方式一：

from django.forms import Form
from django.forms import widgets
from django.forms import fields

 
class MyForm(Form):
 
    user = fields.ChoiceField(
        # choices=((1, '上海'), (2, '北京'),),
        initial=2,
        widget=widgets.Select
    )
 
    def __init__(self, *args, **kwargs):
        super(MyForm,self).__init__(*args, **kwargs)
        # self.fields['user'].widget.choices = ((1, '上海'), (2, '北京'),)
        # 或
        self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption')

方式二：

from django import forms
from django.forms import fields
from django.forms import models as form_model

 
class FInfo(forms.Form):
    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())
    # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())

 

Field
    required=True,               是否允许为空
    widget=None,                 HTML插件
    label=None,                  用于生成Label标签或显示内容
    initial=None,                初始值
    help_text='',                帮助信息(在标签旁边显示)
    error_messages=None,         错误信息 {'required': '不能为空', 'invalid': '格式错误'}
    show_hidden_initial=False,   是否在当前插件后面再加一个隐藏的且具有默认值的插件（可用于检验两次输入是否一直）
    validators=[],               自定义验证规则
    localize=False,              是否支持本地化
    disabled=False,              是否可以编辑
    label_suffix=None            Label内容后缀
 
 
CharField(Field)
    max_length=None,             最大长度
    min_length=None,             最小长度
    strip=True                   是否移除用户输入空白
 
IntegerField(Field)
    max_value=None,              最大值
    min_value=None,              最小值
 
FloatField(IntegerField)
    ...
 
DecimalField(IntegerField)
    max_value=None,              最大值
    min_value=None,              最小值
    max_digits=None,             总长度
    decimal_places=None,         小数位长度
 
BaseTemporalField(Field)
    input_formats=None          时间格式化   
 
DateField(BaseTemporalField)    格式：2015-09-01
TimeField(BaseTemporalField)    格式：11:12
DateTimeField(BaseTemporalField)格式：2015-09-01 11:12
 
DurationField(Field)            时间间隔：%d %H:%M:%S.%f
    ...
 
RegexField(CharField)
    regex,                      自定制正则表达式
    max_length=None,            最大长度
    min_length=None,            最小长度
    error_message=None,         忽略，错误信息使用 error_messages={'invalid': '...'}
 
EmailField(CharField)      
    ...
'''
当在models里想上传FileField或者ImageField字段时，有upload_to属性和default属性，这里的路径，通常会写media路径（在settings.py中设置的文件下载路径，如setting中 MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')，传参upload_to=’img’, 则下载的图片会默认存在os.path.join(BASE_DIR, 'media')下的img中）
'''
FileField(Field)
    allow_empty_file=False     是否允许空文件
    在上传文件的时候，要求request.method必须为POST，而且enctype=’multipart/form-data’
 
ImageField(FileField)      
    ...
    注：需要PIL模块，pip3 install Pillow
    以上两个字典使用时，需要注意两点：
        - form表单中 enctype="multipart/form-data"
        - view函数中 obj = MyForm(request.POST, request.FILES)
 
URLField(Field)
    ...
 
 
BooleanField(Field)  
    ...
 
NullBooleanField(BooleanField)
    ...
 
ChoiceField(Field)
    ...
    choices=(),                选项，如：choices = ((0,'上海'),(1,'北京'),)
    required=True,             是否必填
    widget=None,               插件，默认select插件
    label=None,                Label内容
    initial=None,              初始值
    help_text='',              帮助提示
 
 
ModelChoiceField(ChoiceField)
    ...                        django.forms.models.ModelChoiceField
    queryset,                  # 查询数据库中的数据
    empty_label="---------",   # 默认空显示内容
    to_field_name=None,        # HTML中value的值对应的字段
    limit_choices_to=None      # ModelForm中对queryset二次筛选
     
ModelMultipleChoiceField(ModelChoiceField)
    ...                        django.forms.models.ModelMultipleChoiceField
 
 
     
TypedChoiceField(ChoiceField)
    coerce = lambda val: val   对选中的值进行一次转换
    empty_value= ''            空值的默认值
 
MultipleChoiceField(ChoiceField)
    ...
 
TypedMultipleChoiceField(MultipleChoiceField)
    coerce = lambda val: val   对选中的每一个值进行一次转换
    empty_value= ''            空值的默认值
 
ComboField(Field)
    fields=()                  使用多个验证，如下：即验证最大长度20，又验证邮箱格式
                               fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])
 
MultiValueField(Field)
    PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用
 
SplitDateTimeField(MultiValueField)
    input_date_formats=None,   格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y']
    input_time_formats=None    格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M']
 
FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹
    required=True,
    widget=None,
    label=None,
    initial=None,
    help_text=''
 
GenericIPAddressField
    protocol='both',           both,ipv4,ipv6支持的IP格式
    unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用
 
SlugField(CharField)           数字，字母，下划线，减号（连字符）
    ...
 
UUIDField(CharField)           uuid类型

```



## form校验（三种）

### 1.使用正则

```python
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.validators import RegexValidator

class MyForm(Form):
    user = fields.CharField(
        validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')],

)
```

### 2.自己定义函数，注册到validations

```python
import re
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.exceptions import ValidationError
 
 
# 自定义验证规则
def mobile_validate(value):
    mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$')
    if not mobile_re.match(value):
        raise ValidationError('手机号码格式错误')
 
 
class PublishForm(Form):
    title = fields.CharField(max_length=20,
                            min_length=5,
                            error_messages={'required': '标题不能为空',
                                            'min_length': '标题最少为5个字符',
                                            'max_length': '标题最多为20个字符'},
                            widget=widgets.TextInput(attrs={'class': "form-control",
                                                          'placeholder': '标题5-20个字符'}))
 
 
    # 使用自定义验证规则
    phone = fields.CharField(validators=[mobile_validate, ],
                            error_messages={'required': '手机不能为空'},
                            widget=widgets.TextInput(attrs={'class': "form-control",
                                                          'placeholder': u'手机号码'}))
 
    email = fields.EmailField(required=False,
                            error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'},
                            widget=widgets.TextInput(attrs={'class': "form-control", 'placeholder': u'邮箱'}))
```

### 3.钩子函数

```python
#在form类定义方法，校验用户名和密码，局部钩子函数名称clean_<局部钩子要校验的字段名称>，自建局部钩子函数的返回值要和源码中的返回值一致，即都是返回校验成功后的数据，不成功要rasie ValidationError()错误，全局钩子函数同理，具体请参考源码is_valid函数的执行

    def clean_username(self):
        '''
        单独校验username字段，属于局部钩子
        '''

        value = self.cleaned_data.get("username")
        if "金 瓶 梅" in value:
            raise ValidationError("不符合社会主义核心价值观！")
        else:
            return value


    def clean(self):
        '''
        重写了基类Form中的clean方法，属于全局钩子
        '''
        pwd = self.cleaned_data.get("pwd")
        re_pwd = self.cleaned_data.get("re_pwd")

        if pwd != re_pwd:
            self.add_error("re_pwd", "两次输入的密码不一致！")
            # 两次输入的密码不一致
            raise ValidationError("两次输入的密码不一致！")
        else:
            return self.cleaned_data
```

## 插件

**主要是form中参数widget相关**

## 重点

1. 字段

   ​	-- 用于保存数据，及正则表达式等，为了方便，尽可将form中的字段名和models中的字段名对应相同

2. HTML插件

   ​	-- 即指参数widget，详见其源码

   ​	-- 只能生成form标签相关的html标签

3. 对于特殊的单选多选，数据源是否能够实时更新问题？？？

```python
'''
因为自定义的Form的子类中，字段为类属性，只在创建时初始化一次，之后的值都和程序开始运行时的数据一样，除非程序重启，否则以原代码是不能时时更新的，
'''
# 解决,将choices的赋值写早init函数中，推荐使用这一种
teacher = fields.IntegerField(min_value=1,
                                  label='教师',
                                  widget=widgets.Select(),
                                  error_messages={
                                      'require': '老师不能为空',
                                      'min_value': '老师输入超出范围',
                                  })

    def __init__(self, *args, **kwargs):
        super(ClassForm, self).__init__(*args, **kwargs)
        self.fields['teacher'].choices = models.Teacher.objects.values_list('id', 'name')
        
# 第二种解决方法，使用django.forms.models中Model开头的field，其中的参数quertset及为models.Teacher.objects.values_list('id', 'name')，但是要更改对应models的__str__放法，此处及为teacher的__str__()方法




'''
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
当使用ajax提交时，所有的页面跳转刷新操作都要由html中对应ajax的success函数实现，即使在后端的路由函数中写了跳转刷新等，也是没效果的
'''
```

## Form组件扩展

### 1. 简单扩展

#### 利用form自带的正则扩展

### 2.基于源码的扩展

#### 扩展字段检测函数，即上述的局部钩子函数，只能对指定的字段检测判断

#### 全局钩子。检测整体字段

# django的序列化

```python
# 只有queryset[obj, obj]中是对象的，即是通过modesl.Teacher.objects.all()得到的数据，在转成字符串时，才需要用django的序列化,因为json模块只能对python的自己的数据类型进行序列化，并且在前端对应的ajax中，要反序列化后才能循环
from django.core import serializers
user_list = modesl.Teacher.objects.all()
ret['data'] = serializers.serialize('json', user_list)
```

# tornado源码解析

## 1. 基本示例

```python
import tornado.web
import tornado.ioloop


# 定义处理类型
class IndexHandler(tornado.web.RequestHandler):
    # 添加一个处理get请求方式的方法
    def get(self):
        # 向响应中，添加数据
        # self.write('好看的皮囊千篇一律，有趣的灵魂万里挑一。')  # 相当于django的HttpResponse
        self.render('login.html')

    def post(self):
        username = self.get_argument('username')
        print(username)


# 相当于django的settings
settings = {
    'template_path': 'template',
    'static_path': 'static',
    'static_url_prefix': '/static/',  # STATIC_URL = '/static/
}

if __name__ == '__main__':
    # 创建一个应用对象
    app = tornado.web.Application([
        (r'/index/', IndexHandler)
    ], **settings)
    # 绑定一个监听端口
    app.listen(8888)
    # 启动web程序，开始监听端口的连接,实质是用select.select
    tornado.ioloop.IOLoop.current().start()

```

## 2. 源码执行流程

1. 创建实例，加载配置文件和路由配置(相当于django中的settings.py)

   ```python
   settings = {
       'template_path': 'template', # 设置模板路径
       'statice_path': 'static', # 设置静态文件路径，相当于django中的STATICFILES_DIRS
       'static_url_prefix':'/static/', # 设置静态文件在前端调用时的路径
   }
   app = tornado.web.Application([
       (r'/index/', IndexHandler), # 路由配置
   ], **settings)
   ```

2. 创建socket并监听指定端口

   ```python
   app.listen(8888)
   ```

3. 启动

   ```python
   tornado.ioloop.IOLoop.current().start()
   ```

   

## 3.tornado的异步非阻塞



# 企业官网示例

 ## 1. 组合搜索



## 2. 瀑布流





